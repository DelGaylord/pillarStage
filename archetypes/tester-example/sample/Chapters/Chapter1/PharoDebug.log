THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FileReference>>isEmpty
9 August 2018 4:48:49.690346 pm

VM: Mac OS - x64 - 1011.6 - CoInterpreter VMMaker.oscog-eem.2401 uuid: 29232e0e-c9e3-41d8-ae75-519db862e02c Jun 28 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2401 uuid: 29232e0e-c9e3-41d8-ae75-519db862e02c Jun 28 2018
VM: 201806281256 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Thu Jun 28 14:56:30 2018 CommitHash: a8a1dc1 Plugins: 201806281256 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1166.sha.e2e0250b4eb4da67f7c50b30be2802ca84e5c5b1 (64 Bit)]

FileReference(Object)>>doesNotUnderstand: #isEmpty
	Receiver: File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/Chapters/Chapter1
	Arguments and temporary variables: 
		aMessage: 	isEmpty
		exception: 	MessageNotUnderstood: FileReference>>isEmpty
		resumeValue: 	nil
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'quentin' / 'Desktop' / 'MetacelloTestBook' / 'Book-Chap...etc...


Path class>>from:delimiter:
	Receiver: Path
	Arguments and temporary variables: 
		aString: 	File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/Chapte...etc...
		aDelimiterCharacter: 	$/
		pathClass: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#,->Path>>#, #/->Path>>#/ #'<='->Path>>#'<=' #=-...etc...
		format: 	131072
		layout: 	a VariableLayout
		organization: 	a ClassOrganization
		subclasses: 	{AbsolutePath. RelativePath}
		name: 	#Path
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'FileSystem-Path-Base'


MacStore(FileSystemStore)>>pathFromString:
	Receiver: a MacStore
	Arguments and temporary variables: 
		aString: 	File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/Chapte...etc...
	Receiver's instance variables: 
		maxFileNameLength: 	255


FileSystem>>pathFromString:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aString: 	File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/Chapte...etc...
	Receiver's instance variables: 
		store: 	a MacStore


FileReference(AbstractFileReference)>>/
	Receiver: File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/Chapters/Chapter1
	Arguments and temporary variables: 
		aString: 	File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/Chapte...etc...
	Receiver's instance variables: 
		filesystem: 	a FileSystem
		path: 	Path / 'Users' / 'quentin' / 'Desktop' / 'MetacelloTestBook' / 'Book-Chap...etc...


ConfigurationForPillar>>convertBaseDirectory:
	Receiver: a ConfigurationForPillar
	Arguments and temporary variables: 
		aValue: 	File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/Chapter...etc...
	Receiver's instance variables: 
		parent: 	nil
		properties: 	an OrderedDictionary(#_project->a PRProject[835776512])
		printer: 	a PRTitlePrinter


ConfigurationForPillar(ChrysalConfiguration)>>setConvertedValueOfDeclaredProperty:
	Receiver: a ConfigurationForPillar
	Arguments and temporary variables: 
		aBinding: 	'baseDirectory'->File @ /Users/quentin/Desktop/MetacelloTestBook/Book...etc...
		setter: 	'BaseDirectory:'
		converted: 	nil
	Receiver's instance variables: 
		parent: 	nil
		properties: 	an OrderedDictionary(#_project->a PRProject[835776512])
		printer: 	a PRTitlePrinter


ConfigurationForPillar(ChrysalConfiguration)>>setConvertedValueOf:
	Receiver: a ConfigurationForPillar
	Arguments and temporary variables: 
		aBinding: 	'baseDirectory'->File @ /Users/quentin/Desktop/MetacelloTestBook/Book...etc...
	Receiver's instance variables: 
		parent: 	nil
		properties: 	an OrderedDictionary(#_project->a PRProject[835776512])
		printer: 	a PRTitlePrinter


[ :aBinding | conf setConvertedValueOf: aBinding ] in ConfigurationForPillar class(ChrysalConfiguration class)>>newFromSTONDictionary:
	Receiver: ConfigurationForPillar
	Arguments and temporary variables: 
		stonDictionary: 	a Dictionary('_project'->a PRProject[835776512] 'baseDirectory'...etc...
		conf: 	a ConfigurationForPillar
		aBinding: 	'baseDirectory'->File @ /Users/quentin/Desktop/MetacelloTestBook/Book...etc...
	Receiver's instance variables: 
		superclass: 	ChrysalPillarishConfiguration
		methodDict: 	a MethodDictionary(#attribution->ConfigurationForPillar>>#attributi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationForPillar
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Pillar-Chrysal'


Array(SequenceableCollection)>>do:
	Receiver: an Array('_project'->a PRProject[835776512] 'baseDirectory'->File @ /Users/quentin/Desktop...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aBinding | conf setConvertedValueOf: aBinding ]
		index: 	2
	Receiver's instance variables: 
an Array('_project'->a PRProject[835776512] 'baseDirectory'->File @ /Users/quentin/Desktop...etc...

ConfigurationForPillar class(ChrysalConfiguration class)>>newFromSTONDictionary:
	Receiver: ConfigurationForPillar
	Arguments and temporary variables: 
		stonDictionary: 	a Dictionary('_project'->a PRProject[835776512] 'baseDirectory'...etc...
		conf: 	a ConfigurationForPillar
	Receiver's instance variables: 
		superclass: 	ChrysalPillarishConfiguration
		methodDict: 	a MethodDictionary(#attribution->ConfigurationForPillar>>#attributi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationForPillar
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Pillar-Chrysal'


ConfigurationForPillar class(ChrysalConfiguration class)>>newFromDictionary:
	Receiver: ConfigurationForPillar
	Arguments and temporary variables: 
		stonDictionary: 	a Dictionary('_project'->a PRProject[835776512] 'baseDirectory'...etc...
	Receiver's instance variables: 
		superclass: 	ChrysalPillarishConfiguration
		methodDict: 	a MethodDictionary(#attribution->ConfigurationForPillar>>#attributi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ConfigurationForPillar
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Pillar-Chrysal'


PRProject>>configuration
	Receiver: a PRProject[835776512]
	Arguments and temporary variables: 
		readConfiguration: 	nil
		extension: 	a Dictionary('_project'->a PRProject[835776512] 'baseDirectory'->Fil...etc...
	Receiver's instance variables: 
		properties: 	nil
		baseDirectory: 	File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/...etc...
		status: 	nil


PRProject>>plugins
	Receiver: a PRProject[835776512]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		properties: 	nil
		baseDirectory: 	File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/...etc...
		status: 	nil


PRProject>>prepareForTarget:
	Receiver: a PRProject[835776512]
	Arguments and temporary variables: 
		target: 	a PRCheckBookTarget
	Receiver's instance variables: 
		properties: 	nil
		baseDirectory: 	File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/...etc...
		status: 	nil


PRProject>>build:
	Receiver: a PRProject[835776512]
	Arguments and temporary variables: 
		output: 	a PRCheckBookTarget
	Receiver's instance variables: 
		properties: 	nil
		baseDirectory: 	File @ /Users/quentin/Desktop/MetacelloTestBook/Book-Chapter123/...etc...
		status: 	nil


PRBuildCommandLineHandler>>activate
	Receiver: a PRBuildCommandLineHandler
	Arguments and temporary variables: 
		target: 	a PRCheckBookTarget
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		baseDirectory: 	nil
		configurationInstaller: 	nil
		configuration: 	nil


PRBuildCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PRBuildCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	PRSubCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PRBuildCommandLineHandler>>#activate ...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PRBuildCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Pillar-Cli-Handlers'


[ aCommandLinehandler activateWith: commandLine ] in PRCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PRCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	PRBuildCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | ^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PRCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand...etc...
		startpc: 	62
		numArgs: 	0


PRCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PRCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	PRBuildCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PRCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PRCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(PRBuildCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PRCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PRCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'build'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments | arguments first ]) ] in [ [ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments | arguments first ]) ]
	on: Exit
	do: [ :exit | 
		"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
		self class commandLinePasswordManager hasPasswordSet
			ifTrue: [ Smalltalk snapshot: false andQuit: true ].
		^ self handleExit: exit ] ] in PRCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PRCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


BlockClosure>>on:do:
	Receiver: [ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments |...etc...
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | 
"If the command line is protected by password, we jus...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
		...etc...
		startpc: 	177
		numArgs: 	0


[ [ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments | arguments first ]) ]
	on: Exit
	do: [ :exit | 
		"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the accesProcesses and their stacks: 
Process: a Process in DelaySpinScheduler(DelayMicrosecondScheduler)>>runTimerEventLoop
  stack:

DelaySpinScheduler(DelayMicrosecondScheduler)>>runTimerEventLoop
[ self runTimerEventLoop ] in DelaySpinScheduler(DelayMicrosecondScheduler)>>startTimerEventLoop
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in AtomicSharedQueue>>waitForNewItems
  stack:

AtomicSharedQueue>>waitForNewItems
AtomicSharedQueue>>next
[ | available next |
available := OrderedCollection with: updateQueue next.
[ next := updateQueue nextOrNil ] whileNotNil: [ available add: next ].
self runUpdateFor: available ] in ClyDataSourceUpdateScheduler>>processQueue
BlockClosure>>repeat
ClyDataSourceUpdateScheduler>>processQueue
[ self processQueue ] in ClyDataSourceUpdateScheduler>>ensureRunning
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ isEditingSemaphore wait.
"If pattern has changed, see if we need to filter.
	If not, it's probably an extraneous signal received while we were waiting for 0.2 seconds, and we discard then till we end up waiting for filterChangeSemaphore again"
oldPattern ~= pattern
	ifTrue: [ oldPattern := pattern.
		0.2 seconds wait.
		"Pattern still the same? If not, just loop again and end up waiting for another 0.2 secs"
		oldPattern = pattern
			ifTrue: [ self filter ] ] ] in [ | oldPattern |
oldPattern := nil.
[ isEditingSemaphore wait.
"If pattern has changed, see if we need to filter.
	If not, it's probably an extraneous signal received while we were waiting for 0.2 seconds, and we discard then till we end up waiting for filterChangeSemaphore again"
oldPattern ~= pattern
	ifTrue: [ oldPattern := pattern.
		0.2 seconds wait.
		"Pattern still the same? If not, just loop again and end up waiting for another 0.2 secs"
		oldPattern = pattern
			ifTrue: [ self filter ] ] ] repeat ] in FTFilterFunction>>spawnFilterUpdateThread
  stack:

[ isEditingSemaphore wait.
"If pattern has changed, see if we need to filter.
	If not, it's probably an extraneous signal received while we were waiting for 0.2 seconds, and we discard then till we end up waiting for filterChangeSemaphore again"
oldPattern ~= pattern
	ifTrue: [ oldPattern := pattern.
		0.2 seconds wait.
		"Pattern still the same? If not, just loop again and end up waiting for another 0.2 secs"
		oldPattern = pattern
			ifTrue: [ self filter ] ] ] in [ | oldPattern |
oldPattern := nil.
[ isEditingSemaphore wait.
"If pattern has changed, see if we need to filter.
	If not, it's probably an extraneous signal received while we were waiting for 0.2 seconds, and we discard then till we end up waiting for filterChangeSemaphore again"
oldPattern ~= pattern
	ifTrue: [ oldPattern := pattern.
		0.2 seconds wait.
		"Pattern still the same? If not, just loop again and end up waiting for another 0.2 secs"
		oldPattern = pattern
			ifTrue: [ self filter ] ] ] repeat ] in FTFilterFunction>>spawnFilterUpdateThread
BlockClosure>>repeat
[ | oldPattern |
oldPattern := nil.
[ isEditingSemaphore wait.
"If pattern has changed, see if we need to filter.
	If not, it's probably an extraneous signal received while we were waiting for 0.2 seconds, and we discard then till we end up waiting for filterChangeSemaphore again"
oldPattern ~= pattern
	ifTrue: [ oldPattern := pattern.
		0.2 seconds wait.
		"Pattern still the same? If not, just loop again and end up waiting for another 0.2 secs"
		oldPattern = pattern
			ifTrue: [ self filter ] ] ] repeat ] in FTFilterFunction>>spawnFilterUpdateThread
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
  stack:

[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in [ self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ self schedule.
"It is critical that the following has no suspension point so that
	the test and the wait primitive are atomic. In addition, if the delay
	is no longer being waited on while entering the way we know that it 
	is expired because the delay has already fired."
beingWaitedOn
	ifTrue: [ delaySemaphore wait ]
	ifFalse: [ expired := true ] ] in DelayWaitTimeout>>wait
  stack:

[ self schedule.
"It is critical that the following has no suspension point so that
	the test and the wait primitive are atomic. In addition, if the delay
	is no longer being waited on while entering the way we know that it 
	is expired because the delay has already fired."
beingWaitedOn
	ifTrue: [ delaySemaphore wait ]
	ifFalse: [ expired := true ] ] in DelayWaitTimeout>>wait
BlockClosure>>ensure:
DelayWaitTimeout>>wait
Semaphore>>waitTimeoutMSecs:
[ "OSProcess authors suspected that there were various ways in which OS signals
				could be missed under conditions of heavy load. For that reason, we use
				#waitTimeoutMSecs: with the semaphore, so that if a signal is missed,
				we time out and rescan occasionally anyway (#updateActiveChildrenAndNotifyDead
				sends queryExitStatus which sends waitpid() )
				"
self sigChldSemaphore waitTimeoutMSecs: 1000.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self updateActiveChildrenAndNotifyDead ] in [ [ "OSProcess authors suspected that there were various ways in which OS signals
				could be missed under conditions of heavy load. For that reason, we use
				#waitTimeoutMSecs: with the semaphore, so that if a signal is missed,
				we time out and rescan occasionally anyway (#updateActiveChildrenAndNotifyDead
				sends queryExitStatus which sends waitpid() )
				"
self sigChldSemaphore waitTimeoutMSecs: 1000.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self updateActiveChildrenAndNotifyDead ] repeat ] in OSSVMProcess>>initializeChildWatcher
BlockClosure>>repeat
[ [ "OSProcess authors suspected that there were various ways in which OS signals
				could be missed under conditions of heavy load. For that reason, we use
				#waitTimeoutMSecs: with the semaphore, so that if a signal is missed,
				we time out and rescan occasionally anyway (#updateActiveChildrenAndNotifyDead
				sends queryExitStatus which sends waitpid() )
				"
self sigChldSemaphore waitTimeoutMSecs: 1000.
processSynchronizationDelay wait.	"Avoids lost signals in heavy process switching"
self updateActiveChildrenAndNotifyDead ] repeat ] in OSSVMProcess>>initializeChildWatcher
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ (ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ Smalltalk logError: aString inContext: aContext.

" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ (ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ Smalltalk logError: aString inContext: aContext.

" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ (ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
MessageNotUnderstood(Error)>>defaultAction
MessageNotUnderstood>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

